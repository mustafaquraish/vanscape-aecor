use "lib/sdl.ae"
use "lib/math.ae"
use "lib/vector.ae"

let renderer: &SDLRenderer
let window: &SDLWindow

let mouse_x: i32
let mouse_y: i32

def draw_text(font: &TTFFont, text: string, x: i32, y: i32) {
    let white = SDLColor::make(255, 255, 255, 255)
    let msg_surf = font.render_solid(text, white)
    let msg = renderer.create_texture_from_surface(msg_surf)
    let w = 0
    let h = 0
    msg.query(null, null, &w, &h)
    let rect = SDLRect::make(x, y, w, h)
    renderer.copy(msg, null, &rect)
    msg_surf.destroy()
    msg.destroy()
}

struct Circle {
    x: f32
    y: f32
    radius: f32
}

def Circle::make(x: f32, y: f32, radius: f32): Circle {
    let circ: Circle
    circ.x = x
    circ.y = y
    circ.radius = radius
    return circ
}

def Circle::intersects(this, other: Circle): bool {
    let dx = .x - other.x
    let dy = .y - other.y
    let thres = .radius + other.radius
    return dx * dx + dy * dy < thres * thres
}

struct ScaledImage {
    tex: &SDLTexture
    width: i32
    height: i32
}

def ScaledImage::make(filename: string, width: i32): ScaledImage {
    let img: ScaledImage
    img.tex = renderer.load_image(filename)

    if img.tex == null {
        println("Failed to load image %s", filename)
    }

    let w = 0
    let h = 0
    img.tex.query(null, null, &w, &h)
    let aspect = w as f32 / h as f32

    img.width = width
    img.height = (width as f32 / aspect) as i32
    return img
}

def ScaledImage::rect(&this, x: i32, y: i32): SDLRect {
    return SDLRect::make(
        x as i32 - .width / 2,
        y as i32 - .height / 2,
        .width,
        .height,
    )
}

def ScaledImage::draw(&this, x: i32, y: i32) {
    let rect = .rect(x, y)
    renderer.copy(.tex, null, &rect)
}

def ScaledImage::draw_rotated(&this, x: i32, y: i32, angle: f32) {
    angle = degrees(angle)
    let rect = .rect(x, y)
    renderer.copy_ex(.tex, null, &rect, angle, null, 0)
}

struct AnimatedImage {
    imgs: &Vector // &Vector<&SDLTexture>
    width: i32
    height: i32

    current: i32

    // Counters to keep track of animation
    count: i32
    max_count: i32
}

def AnimatedImage::make(width: i32, height: i32, max_count: i32): AnimatedImage {
    let anim: AnimatedImage
    anim.imgs = Vector::new()
    anim.width = width
    anim.height = height
    anim.max_count = max_count
    anim.current = 0
    anim.count = 0
    return anim
}

def AnimatedImage::add(this, filename: string) {
    let img = renderer.load_image(filename)
    if img == null {
        println("Failed to load image %s", filename)
    }
    // Set up aspect ratio for first image
    if .imgs.size == 0 {
        let w = 0
        let h = 0
        img.query(null, null, &w, &h)
        let aspect = w as f32 / h as f32
        .height = (.width as f32 / aspect) as i32
    }
    .imgs.push(img)
}

def AnimatedImage::rect(&this, x: i32, y: i32): SDLRect {
    return SDLRect::make(
        x as i32 - .width / 2,
        y as i32 - .height / 2,
        .width,
        .height,
    )
}

def AnimatedImage::draw(&this, x: i32, y: i32) {
    let img = .imgs.at(.current) as &SDLTexture
    let rect = .rect(x, y)
    renderer.copy(img, null, &rect)
}

def AnimatedImage::draw_rotated(&this, x: i32, y: i32, angle: f32) {
    let img = .imgs.at(.current) as &SDLTexture
    angle = degrees(angle)
    let rect = .rect(x, y)
    renderer.copy_ex(img, null, &rect, angle, null, 0)
}

def AnimatedImage::update(&this) {
    .count += 1
    if .count >= .max_count {
        .count = 0
        .current += 1
        if .current >= .imgs.size {
            .current = 0
        }
    }
}

struct Butterfly {
    x: f32
    y: f32
    angle: f32
    size: f32
    img: AnimatedImage
}

def Butterfly::make(size: i32): Butterfly {
    let butterfly: Butterfly
    butterfly.x = 0.0
    butterfly.y = 0.0
    butterfly.size = size as f32
    butterfly.img = AnimatedImage::make(size, size, 1)

    // Load all images
    for let i = 1; i < 16; i += 1 {
        let filename = `assets/butterfly/frame{i}.png`
        butterfly.img.add(filename)
        free(filename)
    }

    return butterfly
}

def Butterfly::bounds(&this): Circle {
    return Circle::make(.x, .y, .size / 2.0)
}

def Butterfly::draw(&this) {
    .img.draw_rotated(.x as i32, .y as i32, .angle)
}

def abs(x: i32): i32 {
    if x < 0 {
        return -x
    }
    return x
}

def Butterfly::update(&this) {
    let dx = mouse_x - .x as i32
    let dy = mouse_y - .y as i32
    if abs(dx) + abs(dy) > 4 {
        .angle = -atan2(-dy as f32, dx as f32) + PI / 2.0
    }
    .x = mouse_x as f32
    .y = mouse_y as f32
    .img.update()
}

struct Van {
    x: f32
    y: f32
    size: f32
    angle: f32
    img: ScaledImage
}

def Van::make(size: i32): Van {
    let van: Van
    van.x = 0.0
    van.y = 0.0
    van.size = size as f32
    van.img = ScaledImage::make("assets/van.png", size)
    return van
}

def Van::update(&this, bfly: &Butterfly) {
    let dx = bfly.x - .x
    let dy = bfly.y - .y
    let vel = 5.0
    .angle = atan2(dy, dx)
    .x += vel * cos(.angle)
    .y += vel * sin(.angle)
}

def Van::bounds(&this): Circle {
    return Circle::make(.x, .y, .size / 2.0)
}

def Van::draw(&this) {
    .img.draw_rotated(.x as i32, .y as i32, .angle)
}

struct Bullet {
    x: f32
    y: f32
    vx: f32
    vy: f32
    size: f32
    angle: f32
    img: &ScaledImage
}

def Bullet::new(x: f32, y: f32, vx: f32, vy: f32, img: &ScaledImage, size: i32): &Bullet {
    let bullet = calloc(1, sizeof(Bullet)) as &Bullet
    bullet.x = x
    bullet.y = y
    bullet.vx = vx
    bullet.vy = vy
    bullet.img = img
    bullet.size = size as f32
    return bullet
}

def Bullet::bounds(&this): Circle {
    return Circle::make(.x, .y, .size / 2.0)
}

def Bullet::update(&this) {
    .x += .vx
    .y += .vy
    .angle = atan2(mouse_x as f32 - .x, mouse_y as f32 - .y)
}

def Bullet::draw(&this) {
    .img.draw_rotated(.x as i32, .y as i32, -.angle + PI / 2.0)
}

struct GameState {
    player: Butterfly
    van: Van
    bullets: &Vector

    lives: i32
    score: i32
    best_score: i32

    width: i32
    height: i32

    hemlock_img: ScaledImage
    strawberry_img: ScaledImage

    font_40: &TTFFont
}

def GameState::make(width: i32, height: i32): GameState {
    let game: GameState
    game.player = Butterfly::make(40)
    game.van = Van::make(70)
    game.bullets = Vector::new()

    game.width = width
    game.height = height
    game.best_score = 0

    game.hemlock_img = ScaledImage::make("assets/hemlock.png", 20)
    game.font_40 = TTFFont::load("assets/font.ttf", 40)
    if game.font_40 == null {
        println("Could not load font: %s", TTF::get_error())
        exit(1)
    }

    game.reset()
    return game
}

def GameState::reset(&this) {
    .player.x = .width as f32 / 2.0
    .player.y = .height as f32 / 2.0
    .set_van_to_random_corner()
    for let i = 0; i < .bullets.size; i += 1 {
        let bullet = .bullets.at(i) as &Bullet
        free(bullet)
    }
    .bullets.size = 0
    .score = 0
    .lives = 3
}

def GameState::set_van_to_random_corner(&this) {
    .van.x = (randint() % 2) as f32 * .width as f32
    .van.y = (randint() % 2) as f32 * .height as f32
}

def GameState::out_of_bounds(&this, x: i32, y: i32): bool {
    return x < 0 or x > .width or y < 0 or y > .height
}

def GameState::update(&this) {
    .player.update()
    let player_bounds = .player.bounds()

    .van.update(&.player)
    if .van.bounds().intersects(player_bounds) {
        .set_van_to_random_corner()
        .lives -= 1
    }

    let j = 0
    for let i = 0; i < .bullets.size; i += 1 {
        let bullet = .bullets.at(i) as &Bullet
        bullet.update()

        let off_screen = .out_of_bounds(bullet.x as i32, bullet.y as i32)
        let hit_player = bullet.bounds().intersects(player_bounds)

        // Get rid of the bullet
        if off_screen or hit_player {
            free(bullet)

        // Otherwise, update it and move to the first empty slot
        } else {
            .bullets.data[j] = bullet
            j += 1
        }

        if hit_player {
            .lives -= 1
        }
    }
    .bullets.size = j

    if .lives <= 0 {
        .reset()
    }

    .score += 1
    .best_score = max(.best_score, .score)

    if randint() % 100 < 10 {
        let angle = rand01() * 2.0 * PI
        let bullet = Bullet::new(
            .van.x,
            .van.y,
            4.0 * cos(angle),
            4.0 * sin(angle),
            &.hemlock_img,
            20,
        )
        .bullets.push(bullet)
    }
}

def GameState::draw_overlay(&this) {
    let score_text = `Score: {.score}`
    draw_text(.font_40, score_text, .width / 2 - 100, 10)
    free(score_text)

    let best_text = `Best: {.best_score}`
    draw_text(.font_40, best_text, 40, 10)
    free(best_text)

    let lives_text = `Lives: {.lives}`
    draw_text(.font_40, lives_text, .width - 200, 10)
    free(lives_text)
}

def GameState::draw(&this) {
    .player.draw()
    .van.draw()
    for let i = 0; i < .bullets.size; i += 1 {
        let bullet = .bullets.at(i) as &Bullet
        bullet.draw()
    }
    .draw_overlay()
}

// Required to branch out to emscripten
def one_step(game: &GameState): bool {
    let e: SDLEvent
    let quit = false

    while SDL::poll_event(&e) {
        if e.type == SDL_Quit {
            quit = true
        }
        if e.type == SDL_KeyDown {
            let key = e.key.keysym.sym
            if key == SDLKey_Q or key == SDLKey_Esc {
                quit = true
            }
        }
    }

    SDL::get_mouse_state(&mouse_x, &mouse_y)
    renderer.set_draw_color(0, 0, 0, 255)
    renderer.clear()

    game.update()
    game.draw()

    renderer.present()
    return quit
}
